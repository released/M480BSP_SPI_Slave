; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DENABLE_SPI_SLAVE --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;271    
;;;272    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;273    {
;;;274    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;275    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;276    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;277    	
;;;278    }
;;;279    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.SPI0_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  SPI0_IRQHandler PROC
;;;89     #if defined (ENABLE_SPI_IRQ)
;;;90     void SPI0_IRQHandler(void)
000000  b4f0              PUSH     {r4-r7}
;;;91     {
;;;92     	if (SPI_GET_SSACTIF_FLAG(BridgeSpiPortNum))
000002  491b              LDR      r1,|L3.112|
000004  6948              LDR      r0,[r1,#0x14]
000006  0740              LSLS     r0,r0,#29
000008  d52f              BPL      |L3.106|
;;;93     	{
;;;94     		SPI_SET_SSACTIF_FLAG(BridgeSpiPortNum);
00000a  6948              LDR      r0,[r1,#0x14]
00000c  f0400004          ORR      r0,r0,#4
000010  6148              STR      r0,[r1,#0x14]
000012  2400              MOVS     r4,#0
;;;95     
;;;96     //		SPI_ClearRxFIFO(BridgeSpiPortNum);
;;;97     //		SPI_ClearTxFIFO(BridgeSpiPortNum);
;;;98     
;;;99     		while (!SPI_GET_SSINAIF_FLAG(BridgeSpiPortNum))
;;;100    		{
;;;101    			if (SPI_GET_RX_FIFO_EMPTY_FLAG(BridgeSpiPortNum) == 0)
;;;102    			{
;;;103    				buffer[RxDataCount++] = SPI_READ_RX(BridgeSpiPortNum);
;;;104    			}
;;;105    
;;;106    			if (RxDataCount == MASTER_DATA_NUM)
000014  154d              ASRS     r5,r1,#21
000016  4a17              LDR      r2,|L3.116|
000018  4b17              LDR      r3,|L3.120|
00001a  e015              B        |L3.72|
                  |L3.28|
00001c  05c0              LSLS     r0,r0,#23             ;101
00001e  d501              BPL      |L3.36|
000020  68d8              LDR      r0,[r3,#0xc]          ;103  ; RxDataCount
000022  e004              B        |L3.46|
                  |L3.36|
000024  6b0e              LDR      r6,[r1,#0x30]         ;103
000026  68d8              LDR      r0,[r3,#0xc]          ;103  ; RxDataCount
000028  5416              STRB     r6,[r2,r0]            ;103
00002a  1c40              ADDS     r0,r0,#1              ;103
00002c  60d8              STR      r0,[r3,#0xc]          ;103  ; RxDataCount
                  |L3.46|
00002e  42a8              CMP      r0,r5
000030  d100              BNE      |L3.52|
;;;107    			{
;;;108    				RxDataCount = 0;
000032  60dc              STR      r4,[r3,#0xc]  ; RxDataCount
                  |L3.52|
;;;109    			}
;;;110    			
;;;111    //			buffer[0] = TestCount+1;
;;;112    //			buffer[0] = RxData;	
;;;113    //			SPI_Slave_TX(BridgeSpiPortNum , &buffer[0] , 0x01);
;;;114    		    if ((SPI_GET_TX_FIFO_FULL_FLAG(BridgeSpiPortNum) == 0) && (TxDataCount < MASTER_DATA_NUM	))
000034  6948              LDR      r0,[r1,#0x14]
000036  0380              LSLS     r0,r0,#14
000038  d406              BMI      |L3.72|
00003a  6898              LDR      r0,[r3,#8]  ; TxDataCount
00003c  42a8              CMP      r0,r5
00003e  d203              BCS      |L3.72|
;;;115    		    {
;;;116    		        SPI_WRITE_TX(BridgeSpiPortNum, buffer[TxDataCount]);
000040  5c16              LDRB     r6,[r2,r0]
000042  620e              STR      r6,[r1,#0x20]
000044  1c40              ADDS     r0,r0,#1
;;;117    				TxDataCount++;
000046  6098              STR      r0,[r3,#8]  ; TxDataCount
                  |L3.72|
000048  6948              LDR      r0,[r1,#0x14]         ;99
00004a  0700              LSLS     r0,r0,#28             ;99
;;;118    		    }
;;;119    		}
;;;120    
;;;121    		SPI_SET_SSINAIF_FLAG(BridgeSpiPortNum);
00004c  6948              LDR      r0,[r1,#0x14]
00004e  d5e5              BPL      |L3.28|
000050  f0400008          ORR      r0,r0,#8
000054  6148              STR      r0,[r1,#0x14]
;;;122    //		SPI_DisableInt(BridgeSpiPortNum,SPI_SSACT_INT_MASK);
;;;123    
;;;124    		TxDataCount = 0;
;;;125    		RxDataCount = 0;
000056  609c              STR      r4,[r3,#8]  ; TxDataCount
;;;126    		
;;;127    		printf("SPI_SLAVE : 0x%2X (0x%2X) , TestCount = 0x%2X\r\n" , RxData ,(uint8_t) ~RxData , TestCount);	
000058  60dc              STR      r4,[r3,#0xc]  ; RxDataCount
00005a  7859              LDRB     r1,[r3,#1]  ; RxData
00005c  781b              LDRB     r3,[r3,#0]  ; TestCount
00005e  bcf0              POP      {r4-r7}
000060  43c8              MVNS     r0,r1
000062  b2c2              UXTB     r2,r0
000064  a005              ADR      r0,|L3.124|
000066  f7ffbffe          B.W      __2printf
                  |L3.106|
;;;128    		
;;;129    	}
;;;130    }
00006a  bcf0              POP      {r4-r7}
00006c  4770              BX       lr
;;;131    #endif
                          ENDP

00006e  0000              DCW      0x0000
                  |L3.112|
                          DCD      0x40061000
                  |L3.116|
                          DCD      ||.bss||
                  |L3.120|
                          DCD      ||.data||
                  |L3.124|
00007c  5350495f          DCB      "SPI_SLAVE : 0x%2X (0x%2X) , TestCount = 0x%2X\r\n",0
000080  534c4156
000084  45203a20
000088  30782532
00008c  58202830
000090  78253258
000094  29202c20
000098  54657374
00009c  436f756e
0000a0  74203d20
0000a4  30782532
0000a8  580d0a00

                          AREA ||i.SPI_Function_Simulate||, CODE, READONLY, ALIGN=2

                  SPI_Function_Simulate PROC
;;;132    
;;;133    void SPI_Function_Simulate(void)
000000  b538              PUSH     {r3-r5,lr}
;;;134    {
;;;135    	#if defined (ENABLE_SPI_POLLING)
;;;136    	volatile uint8_t res = 0;
;;;137    
;;;138    	SYS_ResetModule(SPI0_RST);
;;;139        SPI_Open(BridgeSpiPortNum, SPI_SLAVE, SPI_MODE_0, 8, (uint32_t)NULL);
;;;140    	SPI_ClearRxFIFO(BridgeSpiPortNum);
;;;141    	SPI_ClearTxFIFO(BridgeSpiPortNum);
;;;142    
;;;143    //	SPI_SetFIFO(BridgeSpiPortNum,0,0);
;;;144    
;;;145    //	TestCount = 0xAA;
;;;146    //	buffer[0] = TestCount;
;;;147    //	SPI_Slave_TX(BridgeSpiPortNum , &buffer[0] , 0x01);
;;;148    
;;;149    //	buffer[0] = TestCount+1;
;;;150    //	SPI_Slave_TX(BridgeSpiPortNum , &buffer[0] , 0x01);
;;;151    
;;;152    	do
;;;153    	{
;;;154    //		printf("wait for SPI_GET_SSACTIF_FLAG\r\n");
;;;155    	}while(SPI_GET_SSACTIF_FLAG(BridgeSpiPortNum) == 0);
;;;156    	SPI_SET_SSACTIF_FLAG(BridgeSpiPortNum);
;;;157    
;;;158    	while(SPI_GET_SSINAIF_FLAG(BridgeSpiPortNum) == 0)
;;;159    	{
;;;160    //		do
;;;161    //		{
;;;162    //			printf("wait for SPI_GET_SSLINE_FLAG\r\n");
;;;163    //		}while(SPI_GET_SSLINE_FLAG(BridgeSpiPortNum));
;;;164    	
;;;165    		if (SPI_GET_RX_FIFO_EMPTY_FLAG(BridgeSpiPortNum) == 0)
;;;166    		{
;;;167    			buffer[RxDataCount++] = SPI_READ_RX(BridgeSpiPortNum);
;;;168    		}
;;;169    
;;;170    		if (RxDataCount == MASTER_DATA_NUM)
;;;171    		{
;;;172    			RxDataCount = 0;
;;;173    		}		
;;;174    		
;;;175    //		buffer[0] = TestCount+1;
;;;176    //		buffer[0] = RxData;	
;;;177    //		SPI_Slave_TX(BridgeSpiPortNum , &buffer[0] , 0x01);
;;;178    	    if ((SPI_GET_TX_FIFO_FULL_FLAG(BridgeSpiPortNum) == 0)&& (TxDataCount < MASTER_DATA_NUM	))
;;;179    	    {
;;;180    	        SPI_WRITE_TX(BridgeSpiPortNum, buffer[TxDataCount]);
;;;181    			TxDataCount++;
;;;182    	    }
;;;183    	};
;;;184    	
;;;185    	SPI_SET_SSINAIF_FLAG(BridgeSpiPortNum);
;;;186    //	printf("SPI_SLAVE : 0x%2X (0x%2X) , TestCount = 0x%2X\r\n" , RxData ,(uint8_t) ~RxData , TestCount);	
;;;187    
;;;188    	TxDataCount = 0;
;;;189    	RxDataCount = 0;
;;;190    
;;;191    	#elif defined (ENABLE_SPI_IRQ)
;;;192    
;;;193    	SYS_ResetModule(SPI0_RST);
000002  4811              LDR      r0,|L4.72|
000004  f7fffffe          BL       SYS_ResetModule
;;;194        SPI_Open(BridgeSpiPortNum, SPI_SLAVE, SPI_MODE_0, 8, (uint32_t)NULL);
000008  2000              MOVS     r0,#0
00000a  4c10              LDR      r4,|L4.76|
00000c  2204              MOVS     r2,#4
00000e  9000              STR      r0,[sp,#0]
000010  2308              MOVS     r3,#8
000012  0411              LSLS     r1,r2,#16
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_Open
;;;195    
;;;196    	SPI_ClearRxFIFO(BridgeSpiPortNum);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPI_ClearRxFIFO
;;;197    	SPI_ClearTxFIFO(BridgeSpiPortNum);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SPI_ClearTxFIFO
;;;198    
;;;199    	SPI_SetFIFO(BridgeSpiPortNum , 4 , 4);
000026  2204              MOVS     r2,#4
000028  4611              MOV      r1,r2
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SPI_SetFIFO
;;;200    
;;;201    	SPI_EnableInt(BridgeSpiPortNum,SPI_SSACT_INT_MASK);
000030  2102              MOVS     r1,#2
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       SPI_EnableInt
;;;202        SPI_WRITE_TX(BridgeSpiPortNum, 0xFFFFFFFF);    /* Dummy Write to prevent TX under run */
000038  f04f31ff          MOV      r1,#0xffffffff
00003c  6221              STR      r1,[r4,#0x20]
;;;203        NVIC_EnableIRQ(SPI0_IRQn);
00003e  e8bd4038          POP      {r3-r5,lr}
000042  2017              MOVS     r0,#0x17
000044  f7ffbffe          B.W      NVIC_EnableIRQ
;;;204    	
;;;205    	#endif
;;;206    
;;;207    }
;;;208    
                          ENDP

                  |L4.72|
                          DCD      0x0400000d
                  |L4.76|
                          DCD      0x40061000

                          AREA ||i.SPI_Slave_TX||, CODE, READONLY, ALIGN=2

                  SPI_Slave_TX PROC
;;;69     
;;;70     void SPI_Slave_TX(SPI_T *spi , uint8_t *buffer , uint32_t len)
000000  4b06              LDR      r3,|L5.28|
;;;71     {
000002  b510              PUSH     {r4,lr}
;;;72     
;;;73     	#if 1
;;;74         if ((SPI_GET_TX_FIFO_FULL_FLAG(BridgeSpiPortNum) == 0)&& (TxDataCount < len))
000004  695b              LDR      r3,[r3,#0x14]
000006  039b              LSLS     r3,r3,#14
000008  d407              BMI      |L5.26|
00000a  4c05              LDR      r4,|L5.32|
00000c  68a3              LDR      r3,[r4,#8]  ; TxDataCount
00000e  4293              CMP      r3,r2
000010  d203              BCS      |L5.26|
;;;75         {
;;;76             SPI_WRITE_TX(spi, buffer[TxDataCount]);
000012  5cc9              LDRB     r1,[r1,r3]
000014  6201              STR      r1,[r0,#0x20]
000016  1c5b              ADDS     r3,r3,#1
;;;77     		TxDataCount++;
000018  60a3              STR      r3,[r4,#8]  ; TxDataCount
                  |L5.26|
;;;78         }
;;;79     	#else
;;;80         while (TxDataCount < len)
;;;81         {
;;;82             SPI_WRITE_TX(spi, buffer[TxDataCount++]);
;;;83     		while(SPI_IS_BUSY(spi));
;;;84         }
;;;85     
;;;86     	#endif
;;;87     }
00001a  bd10              POP      {r4,pc}
;;;88     
                          ENDP

                  |L5.28|
                          DCD      0x40061000
                  |L5.32|
                          DCD      ||.data||

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;279    
;;;280    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L6.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L6.10|
;;;281    {
;;;282        /*---------------------------------------------------------------------------------------------------------*/
;;;283        /* Init System Clock                                                                                       */
;;;284        /*---------------------------------------------------------------------------------------------------------*/
;;;285        /* Unlock protected registers */
;;;286        SYS_UnlockReg();
;;;287    
;;;288        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;289        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2540          MOV      r5,#0x40004000
000022  f8d50140          LDR      r0,[r5,#0x140]
000026  f02000f0          BIC      r0,r0,#0xf0
00002a  f8c50140          STR      r0,[r5,#0x140]
;;;290    
;;;291        /* Enable External XTAL (4~24 MHz) */
;;;292        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;293    
;;;294        /* Waiting for 12MHz clock ready */
;;;295        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;296    
;;;297        /* Set core clock as PLL_CLOCK from PLL */
;;;298        CLK_SetCoreClock(FREQ_192MHZ);
00003a  481b              LDR      r0,|L6.168|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;299        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;300        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;301    
;;;302        /* Enable UART clock */
;;;303        CLK_EnableModuleClock(UART0_MODULE);
000046  4e19              LDR      r6,|L6.172|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;304    
;;;305        /* Select UART clock source from HXT */
;;;306        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       CLK_SetModuleClock
;;;307    
;;;308        CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL2_SPI0SEL_PCLK1, MODULE_NoMsk);
000058  4e15              LDR      r6,|L6.176|
00005a  2200              MOVS     r2,#0
00005c  2120              MOVS     r1,#0x20
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       CLK_SetModuleClock
;;;309        CLK_EnableModuleClock(SPI0_MODULE);
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       CLK_EnableModuleClock
;;;310    
;;;311    //    CLK_EnableModuleClock(PDMA_MODULE);
;;;312    
;;;313    //	TIMER0_HW_Init();
;;;314    	TIMER1_HW_Init();
00006a  f7fffffe          BL       TIMER1_HW_Init
;;;315    	
;;;316        /* Update System Core Clock */
;;;317        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;318        SystemCoreClockUpdate();
00006e  f7fffffe          BL       SystemCoreClockUpdate
;;;319    
;;;320        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;321        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000072  6be0              LDR      r0,[r4,#0x3c]
000074  f420007f          BIC      r0,r0,#0xff0000
000078  63e0              STR      r0,[r4,#0x3c]
;;;322        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00007a  6be0              LDR      r0,[r4,#0x3c]
00007c  f44000cc          ORR      r0,r0,#0x660000
000080  63e0              STR      r0,[r4,#0x3c]
;;;323    
;;;324        /* Setup SPI0 multi-function pins */
;;;325        SYS->GPA_MFPL |= SYS_GPA_MFPL_PA0MFP_SPI0_MOSI | SYS_GPA_MFPL_PA1MFP_SPI0_MISO | SYS_GPA_MFPL_PA2MFP_SPI0_CLK | SYS_GPA_MFPL_PA3MFP_SPI0_SS;
000082  6b20              LDR      r0,[r4,#0x30]
000084  f2444144          MOV      r1,#0x4444
000088  4308              ORRS     r0,r0,r1
00008a  6320              STR      r0,[r4,#0x30]
;;;326    
;;;327        /* Enable SPI0 clock pin (PA2) schmitt trigger */
;;;328        PA->SMTEN |= GPIO_SMTEN_SMTEN2_Msk;
00008c  6a68              LDR      r0,[r5,#0x24]
00008e  f0400004          ORR      r0,r0,#4
000092  6268              STR      r0,[r5,#0x24]
;;;329    
;;;330        /* Enable SPI0 I/O high slew rate */
;;;331        GPIO_SetSlewCtl(PA, 0xF, GPIO_SLEWCTL_HIGH);
000094  2201              MOVS     r2,#1
000096  210f              MOVS     r1,#0xf
000098  4628              MOV      r0,r5
00009a  f7fffffe          BL       GPIO_SetSlewCtl
00009e  2000              MOVS     r0,#0
0000a0  f8c40100          STR      r0,[r4,#0x100]
;;;332    	
;;;333        /* Lock protected registers */
;;;334        SYS_LockReg();
;;;335    }
0000a4  bd70              POP      {r4-r6,pc}
;;;336    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L6.168|
                          DCD      0x0b71b000
                  |L6.172|
                          DCD      0x57803d10
                  |L6.176|
                          DCD      0x6640000d

                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;260    
;;;261    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;262    {
;;;263    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L7.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;264    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;265    }
;;;266    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;266    
;;;267    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;268    {
;;;269    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L8.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;270    }
;;;271    
                          ENDP

                  |L8.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;246    
;;;247    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;248    {
;;;249        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L9.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;250        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;251    }
;;;252    
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;252    
;;;253    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;254    {
;;;255        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L10.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;256        TIMER_EnableInt(TIMER1);
;;;257        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;258        TIMER_Start(TIMER1);
;;;259    }
000028  bd10              POP      {r4,pc}
;;;260    
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;209    
;;;210    void TMR1_IRQHandler(void)
000000  4914              LDR      r1,|L11.84|
000002  6888              LDR      r0,[r1,#8]
000004  f3c00000          UBFX     r0,r0,#0,#1
;;;211    {
000008  2800              CMP      r0,#0
00000a  d021              BEQ      |L11.80|
00000c  2001              MOVS     r0,#1
00000e  6088              STR      r0,[r1,#8]
;;;212    	static uint16_t CNT_LED = 0;	
;;;213    	static uint16_t CNT_SPI = 0;	
;;;214    	static uint8_t toggle = 0;
;;;215    	
;;;216    //	static uint32_t log = 0;	
;;;217    	
;;;218        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;219        {
;;;220            TIMER_ClearIntFlag(TIMER1);
;;;221    	
;;;222    		if (CNT_SPI++ > 200)
000010  4911              LDR      r1,|L11.88|
000012  88c8              LDRH     r0,[r1,#6]  ; CNT_SPI
000014  1c42              ADDS     r2,r0,#1
000016  80ca              STRH     r2,[r1,#6]
000018  2200              MOVS     r2,#0
00001a  28c8              CMP      r0,#0xc8
00001c  d90c              BLS      |L11.56|
;;;223    		{		
;;;224    			CNT_SPI = 0;
00001e  80ca              STRH     r2,[r1,#6]
;;;225    			toggle ^= 1;
000020  7888              LDRB     r0,[r1,#2]  ; toggle
000022  f0900001          EORS     r0,r0,#1
000026  7088              STRB     r0,[r1,#2]
;;;226    			
;;;227    			if (toggle)
;;;228    			{
;;;229    				set_flag(flag_set_SPI , ENABLE);
;;;230    			}
;;;231    			else
;;;232    			{
;;;233    				set_flag(flag_set_SPI , DISABLE);				
000028  6908              LDR      r0,[r1,#0x10]  ; BitFlag
00002a  d002              BEQ      |L11.50|
00002c  f0400002          ORR      r0,r0,#2              ;229
000030  e001              B        |L11.54|
                  |L11.50|
000032  f0200002          BIC      r0,r0,#2
                  |L11.54|
000036  6108              STR      r0,[r1,#0x10]         ;229  ; BitFlag
                  |L11.56|
;;;234    			}
;;;235    		}
;;;236    
;;;237    		if (CNT_LED++ > 1000)
000038  8888              LDRH     r0,[r1,#4]  ; CNT_LED
00003a  1c43              ADDS     r3,r0,#1
00003c  808b              STRH     r3,[r1,#4]
00003e  f5b07f7a          CMP      r0,#0x3e8
000042  d905              BLS      |L11.80|
;;;238    		{		
;;;239    			CNT_LED = 0;
;;;240    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;241    			LED_Y ^= 1;
000044  4805              LDR      r0,|L11.92|
000046  808a              STRH     r2,[r1,#4]            ;239
000048  6801              LDR      r1,[r0,#0]
00004a  f0810101          EOR      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L11.80|
;;;242    		}
;;;243    		
;;;244        }
;;;245    }
000050  4770              BX       lr
;;;246    
                          ENDP

000052  0000              DCW      0x0000
                  |L11.84|
                          DCD      0x40050100
                  |L11.88|
                          DCD      ||.data||
                  |L11.92|
                          DCD      0x400049c4

                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;53     
;;;54     void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;55     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;56         uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;57         
;;;58         printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L12.56|
00000a  f7fffffe          BL       __2printf
;;;59         for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L12.42|
                  |L12.16|
;;;60         {
;;;61             printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L12.76|
000014  f7fffffe          BL       __2printf
;;;62             if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L12.38|
;;;63             {
;;;64                 printf("\r\n");
000020  a00c              ADR      r0,|L12.84|
000022  f7fffffe          BL       __2printf
                  |L12.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;59
                  |L12.42|
00002a  42ac              CMP      r4,r5                 ;59
00002c  dbf0              BLT      |L12.16|
;;;65             }            
;;;66         }
;;;67         printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L12.88|
000034  f7ffbffe          B.W      __2printf
;;;68     }
;;;69     
                          ENDP

                  |L12.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L12.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L12.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L12.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  main PROC
;;;344    
;;;345    int main()
000000  b508              PUSH     {r3,lr}
;;;346    {
;;;347    	uint32_t cnt = 0;
000002  2400              MOVS     r4,#0
;;;348    
;;;349        SYS_Init();
000004  f7fffffe          BL       SYS_Init
;;;350        /* Init UART to 115200-8n1 for print message */
;;;351        UART_Open(UART0, 115200);
000008  f44f31e1          MOV      r1,#0x1c200
00000c  4825              LDR      r0,|L13.164|
00000e  f7fffffe          BL       UART_Open
;;;352    
;;;353    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000012  f7fffffe          BL       CLK_GetCPUFreq
000016  4601              MOV      r1,r0
000018  a023              ADR      r0,|L13.168|
00001a  f7fffffe          BL       __2printf
;;;354    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001e  f7fffffe          BL       CLK_GetHXTFreq
000022  4601              MOV      r1,r0
000024  a027              ADR      r0,|L13.196|
000026  f7fffffe          BL       __2printf
;;;355    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00002a  f7fffffe          BL       CLK_GetLXTFreq
00002e  4601              MOV      r1,r0
000030  a02a              ADR      r0,|L13.220|
000032  f7fffffe          BL       __2printf
;;;356    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000036  f7fffffe          BL       CLK_GetPCLK0Freq
00003a  4601              MOV      r1,r0
00003c  a02d              ADR      r0,|L13.244|
00003e  f7fffffe          BL       __2printf
;;;357    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000042  f7fffffe          BL       CLK_GetPCLK1Freq
000046  4601              MOV      r1,r0
000048  a031              ADR      r0,|L13.272|
00004a  f7fffffe          BL       __2printf
;;;358    
;;;359    	LED_Init();
00004e  f7fffffe          BL       LED_Init
;;;360    	TIMER1_Init();
000052  f7fffffe          BL       TIMER1_Init
;;;361    
;;;362        /* Got no where to go, just loop forever */
;;;363        while(1)
;;;364        {
;;;365    		if (is_flag_set(flag_set_SPI))
000056  4f35              LDR      r7,|L13.300|
;;;366    		{
;;;367    			SPI_Function_Simulate();
;;;368    		}
;;;369    		else
;;;370    		{
;;;371    			SYS_ResetModule(SPI0_RST);
000058  f8df90d4          LDR      r9,|L13.304|
;;;372    		    SPI_Open(BridgeSpiPortNum, SPI_MASTER, SPI_MODE_0, 8, (uint32_t)NULL);
00005c  4d35              LDR      r5,|L13.308|
;;;373    			LED_R ^= 1;
00005e  4e36              LDR      r6,|L13.312|
000060  46a0              MOV      r8,r4                 ;365
                  |L13.98|
000062  6938              LDR      r0,[r7,#0x10]         ;365  ; BitFlag
000064  0780              LSLS     r0,r0,#30             ;365
000066  d502              BPL      |L13.110|
000068  f7fffffe          BL       SPI_Function_Simulate
00006c  e7f9              B        |L13.98|
                  |L13.110|
00006e  4648              MOV      r0,r9                 ;371
000070  f7fffffe          BL       SYS_ResetModule
000074  2308              MOVS     r3,#8                 ;372
000076  2204              MOVS     r2,#4                 ;372
000078  2100              MOVS     r1,#0                 ;372
00007a  4628              MOV      r0,r5                 ;372
00007c  f8cd8000          STR      r8,[sp,#0]            ;372
000080  f7fffffe          BL       SPI_Open
000084  6830              LDR      r0,[r6,#0]
000086  f0800001          EOR      r0,r0,#1
00008a  6030              STR      r0,[r6,#0]
;;;374    			printf("SPI_MASTER : 0x%2X \r\n" , cnt++);
00008c  4621              MOV      r1,r4
00008e  1c64              ADDS     r4,r4,#1
000090  a02a              ADR      r0,|L13.316|
000092  f7fffffe          BL       __2printf
;;;375    			SPI_ClearRxFIFO(BridgeSpiPortNum);
000096  4628              MOV      r0,r5
000098  f7fffffe          BL       SPI_ClearRxFIFO
;;;376    			SPI_ClearTxFIFO(BridgeSpiPortNum);
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       SPI_ClearTxFIFO
0000a2  e7de              B        |L13.98|
;;;377    		}
;;;378    		
;;;379        }
;;;380    }
;;;381    
                          ENDP

                  |L13.164|
                          DCD      0x40070000
                  |L13.168|
0000a8  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
0000ac  4b5f4765
0000b0  74435055
0000b4  46726571
0000b8  203a2025
0000bc  38640d0a
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L13.196|
0000c4  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000c8  47657448
0000cc  58544672
0000d0  6571203a
0000d4  20253864
0000d8  0d0a00  
0000db  00                DCB      0
                  |L13.220|
0000dc  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000e0  4765744c
0000e4  58544672
0000e8  6571203a
0000ec  20253864
0000f0  0d0a00  
0000f3  00                DCB      0
                  |L13.244|
0000f4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000f8  47657450
0000fc  434c4b30
000100  46726571
000104  203a2025
000108  38640d0a
00010c  00      
00010d  00                DCB      0
00010e  00                DCB      0
00010f  00                DCB      0
                  |L13.272|
000110  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
000114  47657450
000118  434c4b31
00011c  46726571
000120  203a2025
000124  38640d0a
000128  00      
000129  00                DCB      0
00012a  00                DCB      0
00012b  00                DCB      0
                  |L13.300|
                          DCD      ||.data||
                  |L13.304|
                          DCD      0x0400000d
                  |L13.308|
                          DCD      0x40061000
                  |L13.312|
                          DCD      0x400049c0
                  |L13.316|
00013c  5350495f          DCB      "SPI_MASTER : 0x%2X \r\n",0
000140  4d415354
000144  4552203a
000148  20307825
00014c  3258200d
000150  0a00    
000152  00                DCB      0
000153  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  buffer
                          %        512

                          AREA ||.data||, DATA, ALIGN=2

                  TestCount
000000  00                DCB      0x00
                  RxData
000001  00                DCB      0x00
                  toggle
000002  0000              DCB      0x00,0x00
                  CNT_LED
000004  0000              DCW      0x0000
                  CNT_SPI
000006  0000              DCW      0x0000
                  TxDataCount
                          DCD      0x00000000
                  RxDataCount
                          DCD      0x00000000
                  BitFlag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_buffer____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_buffer____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_buffer____REVSH|
#line 402
|__asm___6_main_c_buffer____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_buffer____RRX|
#line 587
|__asm___6_main_c_buffer____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
